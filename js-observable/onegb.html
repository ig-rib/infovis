<html>
<head>
    <script src="http://d3js.org/d3.v4.min.js" charset="utf-8"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
    <!-- Parte de esto se basa en las siguientes p+aginas -->
    <!-- https://www.d3-graph-gallery.com/graph/choropleth_basic.html -->
    <!-- https://observablehq.com/@duynguyen1678/choropleth-with-tooltip -->
    <!-- Import google fonts -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;1,100;1,300;1,400;1,500&display=swap" rel="stylesheet"> 
</head>
<body>
    <h1 class="the-title">Average Cost of 1GB of Data (USD)</h1>
    <div class="svg-container">
        <svg id="my_dataviz" width="1500" height="750"></svg>
    </div>
    <div id="legend1"></div>
    <div class="zoom-tips">Drag and zoom available!</div>
    <div class="tooltip"></div>
</body>
<script type="text/javascript">

    let svg = d3.select("svg")
    let width = svg.attr("width")
    let height = svg.attr("height")

    // Esto es para el zoom. Es una más o menos out of the box de d3
    const zoom = d3.zoom()
      .scaleExtent([1, 8])
      .on('zoom', zoomed);

    let path = d3.geoPath()
    let projection = d3.geoMercator()
        .scale(200)
        .center([0,20])
        .translate([width/2, height/2])
    
    let data = d3.map()
    let colorScale = d3.scaleThreshold()
        .domain([0.1, 1, 2, 5, 10, 20, 30])
        .range(d3.schemeBlues[7])
    // Esto sirve para fetchear los 2 archivos (async) y manejarlos juntos después
    d3.queue()
        .defer(d3.json, "https://raw.githubusercontent.com/ig-rib/infovis/python/js-observable/custom.geo.json")
        .defer(d3.csv, 'https://raw.githubusercontent.com/ig-rib/infovis/python/js-observable/Costof1GBofData.csv',
            // Para los datos del csv de 1GB, lo que se hace es agregarle al elemento que tenga la key "[Nombre del país]" el valor de AP (avg price etc)
            function(d) { data.set(d.Country, +d.AP) })
        .await(ready);

    function ready(error, topo) {

        // console.log(data)
        console.log(projection)
        // Dibujo del mapa
        svg.append("g")
            .attr("id", "map")
            .selectAll("path")
            .data(topo.features)
            .enter()
            .append("path")
                .attr("class", "country")
                // d es un atributo de los svgs para determinar el 
                // camino, en este caso de los bordes de los países.
                // Por simplicidad, se usa geoPath con los settings definidos
                // antes (projection)
                .attr("d", d3.geoPath()
                .projection(projection)
                )
                // Con esto se le asigna el valor a cada país
                .attr("fill", function (d) {
                    // console.log(d)
                    // Los valores de AP que se fijaron antes por nombre del país
                    // se usan ahora
                    d.total = data.get(d.properties.name) || 0;
                    return colorScale(d.total);
                })

        // https://observablehq.com/@duynguyen1678/choropleth-with-tooltip
        const Tooltip = d3.select("div.tooltip")
            .style("position", "absolute")
            .style("pointer-events", "none")
            .style("opacity", 0)

        svg
            .selectAll("path")
            .on("mouseover", function(d, index) {
                Tooltip.style("visibility", "visible")
                    .style("top", (event.pageY)+"px")
                    .style("left",(event.pageX)+"px")
                    .style("opacity", 0.95)
                    .text(`${d.properties.name}: ${d.total}`)
                // Tooltip.attr("transform", `translate(${d3.pointer(event, this)})`)
            })
            .on("mousemove", function(d, index) {
                // console.log(d)
                Tooltip
                    .text(`${d.properties.name}: ${d.total}`)
                    .style("left", (event.pageX + 20) + "px")
                    .style("top", (event.pageY) + "px")
                // Tooltip.attr("transform", `translate(${d3.pointer(event, this)})`)
                d3.select(this)
                    .attr("stroke", "red")
                    .raise();
                })
            .on("mouseleave", function() {
                
                // Tooltip.style("visibility", "hidden")
                Tooltip.style("opacity", 0)
                    .text('')
                d3.select(this)
                .attr("stroke", null)
                .lower();
            })
        svg.call(zoom);
    }

    // La función de zoom usa el atributo html transform
    function zoomed() {
      svg.select("#map")
        .selectAll('path') // To prevent stroke width from scaling
        .attr('transform', d3.event.transform);
    }
    
    let legendElement = legend({
    color: colorScale,
        title: "Cost per 1GB (USD)",
        tickSize: 0,
    })

    // and then append to some element
    document.querySelector("#legend1").append(legendElement);

// Código de https://observablehq.com/@d3/color-legend con leves modificaciones para d3.js v4
function legend({
        color,
        title,
        tickSize = 6,
        width = 320, 
        height = 44 + tickSize,
        marginTop = 18,
        marginRight = 0,
        marginBottom = 16 + tickSize,
        marginLeft = 0,
        ticks = width / 64,
        tickFormat,
        tickValues
        } = {}) {

        const svg = d3.create("svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height])
            .style("overflow", "visible")
            .style("display", "block");

        let tickAdjust = g => g.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
        let x;

        // Continuous
        if (color.interpolate) {
            const n = Math.min(color.domain().length, color.range().length);

            x = color.copy().rangeRound(d3.quantize(d3.interpolate(marginLeft, width - marginRight), n));

            svg.append("image")
                .attr("x", marginLeft)
                .attr("y", marginTop)
                .attr("width", width - marginLeft - marginRight)
                .attr("height", height - marginTop - marginBottom)
                .attr("preserveAspectRatio", "none")
                .attr("xlink:href", ramp(color.copy().domain(d3.quantize(d3.interpolate(0, 1), n))).toDataURL());
        }

        // Sequential
        else if (color.interpolator) {
            x = Object.assign(color.copy()
                .interpolator(d3.interpolateRound(marginLeft, width - marginRight)),
                {range() { return [marginLeft, width - marginRight]; }});

            svg.append("image")
                .attr("x", marginLeft)
                .attr("y", marginTop)
                .attr("width", width - marginLeft - marginRight)
                .attr("height", height - marginTop - marginBottom)
                .attr("preserveAspectRatio", "none")
                .attr("xlink:href", ramp(color.interpolator()).toDataURL());

            // scaleSequentialQuantile doesn’t implement ticks or tickFormat.
            if (!x.ticks) {
            if (tickValues === undefined) {
                const n = Math.round(ticks + 1);
                tickValues = d3.range(n).map(i => d3.quantile(color.domain(), i / (n - 1)));
            }
            if (typeof tickFormat !== "function") {
                tickFormat = d3.format(tickFormat === undefined ? ",f" : tickFormat);
            }
            }
        }

        // Threshold
        else if (color.invertExtent) {
            const thresholds
                = color.thresholds ? color.thresholds() // scaleQuantize
                : color.quantiles ? color.quantiles() // scaleQuantile
                : color.domain(); // scaleThreshold

            const thresholdFormat
                = tickFormat === undefined ? d => d
                : typeof tickFormat === "string" ? d3.format(tickFormat)
                : tickFormat;

            x = d3.scaleLinear()
                .domain([-1, color.range().length - 1])
                .rangeRound([marginLeft, width - marginRight]);

            svg.append("g")
            .selectAll("rect")
            .data(color.range())
            .enter().append("rect")
                .attr("x", (d, i) => x(i - 1))
                .attr("y", marginTop)
                .attr("width", (d, i) => x(i) - x(i - 1))
                .attr("height", height - marginTop - marginBottom)
                .attr("fill", d => d);

            tickValues = d3.range(thresholds.length);
            tickFormat = i => thresholdFormat(thresholds[i], i);
        }

        // Ordinal
        else {
            x = d3.scaleBand()
                .domain(color.domain())
                .rangeRound([marginLeft, width - marginRight]);

            svg.append("g")
            .selectAll("rect")
            .data(color.domain())
            .enter().append("rect")
                .attr("x", x)
                .attr("y", marginTop)
                .attr("width", Math.max(0, x.bandwidth() - 1))
                .attr("height", height - marginTop - marginBottom)
                .attr("fill", color);

            tickAdjust = () => {};
        }

        svg.append("g")
            .attr("transform", `translate(0,${height - marginBottom})`)
            .call(d3.axisBottom(x)
                .ticks(ticks, typeof tickFormat === "string" ? tickFormat : undefined)
                .tickFormat(typeof tickFormat === "function" ? tickFormat : undefined)
                .tickSize(tickSize)
                .tickValues(tickValues))
            .call(tickAdjust)
            .call(g => g.select(".domain").remove())
            .call(g => g.append("text")
                .attr("x", marginLeft)
                .attr("y", marginTop + marginBottom - height - 6)
                .attr("fill", "currentColor")
                .attr("text-anchor", "start")
                .attr("font-weight", "bold")
                .text(title));

        return svg.node();
        }

        function ramp(color, n = 256) {
        const canvas = DOM.canvas(n, 1);
        const context = canvas.getContext("2d");
        for (let i = 0; i < n; ++i) {
            context.fillStyle = color(i / (n - 1));
            context.fillRect(i, 0, 1, 1);
        }
        return canvas;
        }
</script>
<style>
    div.tooltip {
        opacity: 0;
        background-color: white;
        border: solid;
        min-width: max-content;
        border-width: 1px;
        border-radius: 1px;
        padding: 5px;
        font-family: 'Roboto', sans-serif;
        font-weight: 300;
    }
    .the-title {
        display: flex;
        justify-content: center;
        font-family: 'Roboto', sans-serif;
    }
    .svg-container {
        display: flex;
        justify-content: center;
    }
    .zoom-tips {
        font-family: 'Roboto', sans-serif;
        font-size: 20px;
        display: flex;
        justify-content: center;
    }
    #legend1 {
        display: flex;
        justify-content: center;
    }
</style>
</html>